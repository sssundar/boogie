Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2016-07-01T19:36:35-07:00

====== sanity-check-hangouts ======
Created Friday 01 July 2016

**Get a hangouts session going, ignoring the display/doodle completely. Test effect of size & frequency on ordering & latency for programmatic messages.** 

From the Hangouts reference on "Writing Apps": //You can store approximately 1MB of data in the shared state object; each delta can be about 10K each. //Elsewhere they state that programattic delta updates can be at maximum 10 per second, with a suspension of 1 second if you exceed that. Expect 300 ms latency. 

So we have 10k, 10Hz to play with with a 300 ms delay. Assume 5Hz, 10k deltas. Allowing 10kBytes, and say in each byte we pack [0-128|bw] for a run, then we see we can take a 1080x1920 = 2,073,600 pixel image with many runs and at best turn it into 16,200 bytes. Not good enough. So we have a limited drawing area, or we use a coarser grid. Say, full screen but 1/4 resolution, which turns into 4050 bytes per delta. and even then, the deltas can be diffs, so even better. We'll start with full-updates, though, at 1/4 resolution and compression, expansion on either end.

The app itself can for now be a Hangouts app run from within Hangouts. I guess the Hangouts API isn't yet allowing other apps to call it.

What I'm seeing on a closer look is that it's not so straightforward to do it this way. 
	Skype has an API documentation that is hard for me to understand
	Hangouts allows internal apps only and I don't find it so simple to set up either
	
Seems to me my best bet for a quick setup is a quick and dirty Python web server with whitelisted inputs from post, which delivers content via GET requests with Javascript to refresh the page. As a first test, I mean. I can run the server on an old laptop or Pi 2 later. For now it'll get me off the ground with this. 

**Ok, so the idea now is: **
1) Set up a HTTP web server in Python with a programatically generated BMP (or a pixel snake) posted to and displayed at the index page, and refresh with JavaScript on the laptop to view
	Set up a POST form (hidden) and send coded text for decoding (with a whitelist and parsing at the server end) to demo error handling, and display the bitmap suggested.
2) Write a simple drawing app (post to website what is drawn, encoded, periodically). View it on a browser on my laptop and see resolution, timing, data usage, lag, etc.

I don't think there are too many security issues here so long as I filter the form input and have only these two interfaces - get and post, without additional parameters or scripts.

Ok, onto (1).

**Set up a HTTP web server in Python using Cherry Py that is publically visible with a domain mapping, which displays "Hello World."**

[*] Installed CherryPy using pip for Python 2.7 using sudo
[*] Found how to change socket mappings so CherryPy servers are publically visible
[*] Wrote Hello World script in Python on port 8080 allowing public connections
[*] Viewed webpage using my phone but only with local IP (192.168.1.5:8080)
	[x] Unable to view webpage using public IP because router apparently can't rewrite internal requests using the external IP
	[x] Unable to view webpage using public IP DNS lookup on Athimber's computer (different router)
	[ ] Can also try Patti's 3G connection on her table (no need, see below)
[*] Set up DuckDNS auto-updater on my Linux computer.
	[ ] Need to check if this works after a reboot (Not Done)
	[*] Not anymore - see below.
[*] Attempting to set up a simple HTTP web server in the cloud so that I don't have to worry about port forwarding on routers I don't own
	[*] Amazon AWS will cost ~100-220 a year depending on how far in advance I pay. 
	[*] It makes no sense in the long term. I can set up a server on my Pi and leave it running, and figure out port forwarding later.
	[*] But for now, it makes sense, even paid. I can use the free tier easily though for testing.
	[*] Created free-tier EC2 instance with SSH, HTTP, and HTTPS ports open, running Ubuntu 14.04 server LTS with limited storage. 
	[*] Downloaded .pem file for SSH but will not be syncing to Github, obviously.
	[*] https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AccessingInstancesLinux.html
	[*] Instance is running in N. California
		[*] DNS ec2-54-67-127-196.us-west-1.compute.amazonaws.com
		[*] ID i-1c115ca9
		[*] to SSH in, from the boogie security folder
			[*] ssh -i boogie-rev-a-1.pem ubuntu[[@ec2-54-67-127-196.us-west-1.compute.amazonaws.com]]
		[*] Success in SSH
		[*] sudo apt-get update & sudo apt-get install python-pip & pip install cherrypy and we're ready to start!
		[*] Use SCP for file transfer to home directory (~), from the boogie security folder
			[*] scp -i boogie-rev-a-1.pem [[../boogie/src/helloworld.py]] ubuntu[[@ec2-54-67-127-196.us-west-1.compute.amazonaws.com]]:~
		[*] Set up CherryPy and the Hello World code on HTTP (port 80), making sure to use sudo python .. for root priviledges to bind port 80
			[*] Works!! I can access the public IP (DNS) and see Hello World.
			[*] Let's push to Github to preserve this data. Also, let's back up the .pem file somewhere safe.

//Note, if I search for files or html documents that aren't there (e.g. index.html) CherryPy dumps traceback to the user. Not great.//

**Set up a HTTP web server in Python with a programatically generated image (of a pixel snake) posted to and displayed at the index page, and refresh with JavaScript on the laptop to view. Set up a POST form (hidden) and send coded text for decoding (with a whitelist and parsing at the server end) to demo error handling, and display the bitmap suggested.**

Here's the idea. 

[*] On the laptop, write a Python script that generates a pixels nake going from top left to bottom right, updating once every 200 ms (parametric size, frequency). 
	[*] See src/image_size_tests.py 
	[*] A 200x200 grid as a PNG zoomed to 300% is 5.7kB and looks like it could handle handwriting. Then again, a normal display now is 1080x1920, so that's 1/5 x 1/10 of the size of the screen, or almost 1/50 of the resolution allowed by the screen. We'll have to play and see. But 5.7kB is reaching a fairly large size. Remember, with 10k images we're expecting about 5.5 hours of talk time for a 2 Gb data outbound to Amma's phone - well beyond her limit unless she's on WiFi (likely).
	[*] Notice at 5Hz this leads to about 240kbits per second required upload speed. That's pretty reasonable nowadays in America. What about India? Not sure. Let's try it.
	[*] P.S. 5Hz means my hard disk drive can't keep up with it - I see updates about once a second. Makes sense.
	[*] I feel this resolution/update frequency aren't going to be good enough. I think I'll need slower & larger. Problem is, Thatha tends to erase his board a LOT, and write quickly. Hm. 
	[*] Ok, let's see what the size is with text RLE, why not.
		[*] Well, with random images (worst case) RLE turns out to be 20kB on average. So that's unfortunate, because PNGs can represent this in 5.7kB. Presumably for other situations RLE does a lot better. We should try it on an image of handwritten text.
		[*] For instance, a random image PNG is 5.7k but a 200x200 written "Hi!" in BW is only 906 bytes. So even RLE will be ok here, I think. Let's try it.
		[*] Yep, the PNG is 906 bytes, and the RLE is 514 bytes. The difference isn't too much, but it shows handwriting isn't so bad as we thought, and we can play with a few types of compression algorithms! Of course, the tradeoff is between space/time. There are usually hardware compression/decompression algorithms for PNG deflate. The RLE needs to be done in SW so it'll be way slower most likely.
[ ] Set up the webserver so that it has a hidden post & get form with internal decoding, and so that it displays the png on the index. Keep things static for now.
	[*] http://docs.cherrypy.org/en/latest/tutorials.html#tutorial-1-a-basic-web-application
	[*] Well, I don't quite like the idea of POSTing files, as it seems annoying to do programmatically with a form submission. I know it's possible, but for now let's stick with RLE encoding/decoding. 
	[*] Ok, so I'll use put, get and have python scripts on either side updating and saving files to disk. One will put a sequence of handwritten '1,2,3,4,5' in sequence, RLE of course, and the other will parse it right back out on the server side, converting it to an image that is displayed. The page should refresh via html or javascript. 
	[*] So screw the RESTful API. Let's just use one function to take a text argument, and another to deliver an image to the screen.
	[*] I did find a reference for how to stream files byte by byte to disk on the server side. That might be more useful later.
	[*] Ok, lets assume a text string RLE encoded with bytes of the form 0-128 | bw, b = 0, w = 1. Then using sys.byteorder in Python to confirm both my laptop & the EC2 instance are little endian, which I guess doesn't matter for single characters..
	[*] Now: setting up webserver.
		[*] Made a ~/public/images directory and placed the barebones.py CherryPy script in [[~/]] as well for local testing
		[*] Without the response header saying it's text, I'm seeing 0.2 second refresh and HTML as expected
		[*] With a picture in the public/images folder, I see the image. It flickers annoyingly. Something will have to be done in the app probably.
		[*] Now, setting it up on EC2.. works as expected.
			[*] Had to install PIL as Pillow
[*] Use python's equivalent of wget for post to programattically post the snake and watch it evolve, to see what frame skipping, etc. look like. Play with update frequencies, resolution (encoding size). See what Amazon's usage statistics look like just for kicks.
	[*] Actually, playing with 0-5 instead of snake. Just want to see updates, skipping.
	[*] Always test locally first.. easier.
	[*] Encoding the run lengths as a 0x00-0xFF was a bad idea. Some of those aren't valid unicode characters. So I should do this: double the size to about 1kB for this, have the first character be the first color ('b' or 'w') and we know it toggles after that. Therefore the rest can just be the 0xXX encoding.
	[*] This did it. I definitely get skipping in EC2 with 200 ms POSTs. If I slow it to 2 second updates, there's no skipping. 
	[*] Deadline:** July 3rd afternoon.**
[*] Work on a basic design for the doodle app - e.g. just drawing. No Skype. 
	[*] Had to install a few extra (older) SDKs to Android Studio to get layout rendering to simulate
	[*] Ok, followed steps more or less. 
	[*] Gradle build time is obscene (>@ hours). Fixed by changing build-tools, SDK version.
	[*] Don't seem to have Android debug bridge installed.. oh, Google dropped support for 32 bit systems. Whoops. Stackoverflow to the rescue.
	[*] Laptop/Android Studio recognize Nexus 7 fine now. 
	[*] Looks awesome. Some issues, noted below. Erasure works fine. 
	[*] Added no autorotate. No screen erasure now except with back button & erase button. Can disable back button later.
[*] Let's now work on getting a bitmap RLE'd and sending out via HTTP post/put.
	[ ] Bitmaps in Android have a built in PNG compression and downsampling function, so that's great. There are also ways to send PNGs via POST. Seems like it'd be worth trying RLE first, then defaulting to that. 
	[*] Let's first set up a 1 second interrupt
	[*] Downsample the bitmap immutably to 200x200, and compute the RLE in color,run,run,run format.
	[*] Figure out HTTP post in Android
	[*] Build, test it on the Nexus/Browser after spinning up the EC2 instance. Works!
	[*] Success on this is just.. get it working, fast. I want to see about resolution & bandwidth, lag, usability, clunkiness factor, ASAP.
	[*] Deadline:** July 5th evening**
[*] Ok, there is massive lag. At least 2 seconds, even with http-gets at 0.2seconds and http-post at 0.4 seconds. Looking at the network traffic on the Android monitor it's clear the processing is taking about 1 second on the tablet, so we have 1 second delay there, followed by 300 ms lag, followed by up to 0.2 seconds lag on our end on the browser, so duh it's taking 2-10 seconds to update. Not great. 

[*] Based on what I've seen so far, if VoIP can handle 64kbps+ streaming **real time with <0.5s detectable delay**, I should be able to find a way to speed this up a lot and make it more reliable. This is the priority, because the rest of it - an app that receives data, handshakes, VoIP, speakers, these are solved problems. I can handle that later. 
[*] Test paid options like ScreenMeet with a doodle app to see how much better things can get
	[*] Several thoughts shown below, but VERY easy to use, and certainly cheaper than EC2 instance. Might be worth it. Should show Patti and see what she thinks of using it, and try to teach Thatha too.

[ ] Look into Latency with EC2 & India-US, look into delay calculations, variation
	[ ] Internet connectivity checks periodically - how often does it "cut off?"
	[ ] Maybe sending out data every 0.4s is overloading the server or typing up the file we're trying to display on the webserver index
		[ ] Check if server post-complete-post overlap happening?
	[ ] I need numbers on this
		[ ] I need to have a log on the webserver to see how often post data is received, and flags to say whether there is overlap.
		[ ] I should keep track of timestamps on the Android side (debug logs) as well, just to see how often it thinks it's sending out data
			[ ] Don't ignore those errors in the logs..
			[ ] What is the processing time?
		[ ] A client app as well as a source/server would help us, too, as then the server wouldn't need to render a PNG on each POST, it could just send out the RLE encoding
	[ ] Once we know where the lag/variable delay is coming from we can figure out how to stop it. If it's networking - diffs, use proper libraries, ... if it's processing, PNG, deflate, etc.
[ ] Work on a basic http get app for the receiver as well (build for my phone)
[ ] Add in VoIP demo to me alone
[ ] Deadline:** July 6th evening**

[ ] Demo to Thatha with me, first, then Amma (web-only + actual phone, or Video Conference so he can see she can see).
[ ] Observe and make notes on Thatha's usage patterns 
[ ] Deadline: **July 7th evening**


[ ] Notes on ScreenMeet/doodle app
	[ ] wow, that looked great, but it had up to 13 seconds delay from the tablet to the phone (i'm just assuming their servers are in USA, so it's a good estimate for my app too).
	[ ] it's absolutely doing a diff of some kind, and they allow a speed/quality tradeoff - when just handwriting in a doodling app where most things stayed the same there was 1 second delay at most, and sometimes much less
	[ ] I can do diffs really easy because I only have to deal with binary images - just subtract the old and new bitmap, and encode THAT, and handle clear separately
	[ ] this only helps if processing is a negligible fraction of the time spend on this
	[ ] I should absolutely test whether the server speeds up if it has to do less processing there itself - and hey, android can just separately deal with rendering, i could up my resolution a lot this way (another thing the screen share has on me is that it seems to have a larger transfer window - but I need to see what my 200x200 looks like scaled to the phone window..)
	[ ] I also found a few sites saying I'm using the wrong libraries and it could be seriously slowing down my networking 
		[ ] https://developer.android.com/training/articles/perf-tips.html#ObjectCreation
		[ ] https://www.toptal.com/android/top-10-most-common-android-development-mistakes

[ ] I think it'd be worth as a first pass putting in a "done" button so Thatha can tell Amma he's done writing, or at least to put in some kind of two way communication so he knows when she's seen what he's written. Maybe something as simple as a counter that resets every time there's a diff in the JSON string. 
[ ] Ok, well, I should try out free/paid options to see what kind of lag they have, and see what DeadSimpleScreenSharing lag is, and then look into ways of speeding this up. I mean, clearly, the post-processing is the killer - though in fairness, the network traffic is taking that second, not the processing. Timing will help resolve this stuff, pinpoint where to focus effort.

[ ] Issues noted with drawing so far:
	[ ] Sound is VERY low - how's VoIP going to work? Get an app.. but then need one with an API, or set it up and make sure they know not to mess with it.
	[ ] Perhaps an indexing method (diff, unique id, and handshake) will make sure thatha doesn't erase early. It might also lower spurious updates. Perhaps the webserver is having timing issues too, and this will help resolve them (don't send unnecessarily if nothing has changed). 
	[ ] Be careful to use solid/striped or something other than red/green as colors are hard to tell apart I bet as we get older.
	[ ] DISABLE auto-turn off when this app is on!! 
	[ ] Don't check for connectivity. What happens if I don't have it?
	[ ] Timing on the transmits - is it actually finishing the thread run() in 1 second or less?
	[ ] What happens to the server if I pass in bad JSON or a string without the necessary field?
	[ ] Home, Switch buttons are fine, don't erase drawing. Back button erases drawing. Probably too much of a pain to remove them.
	[ ] Might want to move erase button to top so Thatha has no chance of accidentally bringing in notification screen and exiting out. Try it with him.
	[ ] Line width is fine. Dots are a bit difficult. Should see if he gets used to it. 
	[ ] Even with hand resting against tablet, because screen doesn't go to edges, no push factor here. Especially snce he's right handed.
	[ ] Disable back button.
[ ] Don't know what this does to size of the message. Need to check Amazon EC2 usage, and can also store logs of this sort of information on the server - timing between observed requests, and classification of the requests to see if even the server sees loss or overlap or other weird timing.
[ ] Putting unique indexes (large, large wrapping #) on these messages may help order them so they can be displayed well despite the slow update. I can also have talkback so the app knows if its message has been received by Amma.

[ ] Aesthetics - usability - home buttons, see how Thatha uses the tablet, make it easier for his use. How to avoid recognizing his hand pressure as a press in the doodle? Look for open-source doodle code with APIs if possible to grab the screen..
[ ] Remote control of Tablet - Remote Update of App - App without Developer Mode
[ ] Flashing light to say "sent" so Thatha knows when he can clear - and send before clear so it's on record. Allow scrolling of saved sessions in real time so Amma can review notes.
[ ] Add in VoIP to Amma, Balu mama, Vikram, Suman, ... 
[ ] Make VoIP optional in case of low bandwidth
[ ] Add save-session features for client app?
[ ] Webserver security & authentication
	[ ] Size limits on post data
	[ ] Post, not put, as otherwise RLE images stored in browser..
[ ] Cleanup last file so no local data exists on server.
[ ] Look into RPi2 webserver hosting & port forwarding, and network monitoring for security. 






